\subsection{Universal Authentication Framework}

The \glsfirst{uaf} is \gls{fido}'s solution for a passwordless experience and standardized in the \gls{itu} recommendation \gls{itu}-T X.1277. It uses local and native device authentication, such as biometrics, to authorize the user. \gls{uaf} does not feature \gls{2fa} but is instead designed as a direct replacement for the login with passwords. It is based on public-key cryptography with the use of challenge-response authentication to prevent replay attacks. The goal of the \gls{uaf} is to provide a generic \gls{api} that enables interoperability and unified user experience between different operating systems and clients.\footcites[See][249]{Schwartz2018}[See][197--198]{dasgupta2017multi}[See][]{itu-uaf}

It features three key components, the \textit{\gls{uaf} client}, the \textit{\gls{uaf} server}, and the \textit{\gls{uaf} authenticators}. Besides that, the alliance offers a centralized metadata service. The communication between the client and the authenticator is performed via the \gls{uaf} \gls{asm}, which offers a standardized \gls{api} for the client to access and detect the different authenticators. Each authenticator is identified by the \gls{aaid}, a unique model ID that comprises the vendor and model ID. The \gls{fido} alliance centrally assigns and manages the vendor ID. Further, at manufacturing a private attestation key is inserted into the authenticator which can and will not change.\footcites[See][145]{10.1007/978-3-319-26502-5_10}[See][8]{uaf-protocol}

\autoref{fig:uaf_architecture} on the next page shows the \gls{uaf} architecture, where the user device is responsible for the communication between the authenticator, \gls{asm}, \gls{fido} client, and the corresponding web browser or (mobile) app. The web browser is also called the user agent. The \gls{rp}, commonly being a web server, and \gls{fido} server are responsible for secure communication over the \gls{uaf} protocol between the user device and \gls{rp}. Further duties of the \gls{rp} are authenticator validation and user authentication. The metadata service updates the database of approved, genuine, and certified authenticators that the \gls{fido} uses for authenticator validation. The protocol defines four different uses cases, which are explained in more detail below:\footcites[See][4]{uaf-protocol}

\begin{enumerate}
	\item registration of the authenticator
	\item user authentication
	\item transaction confirmation
	\item de-registration of the authenticator
\end{enumerate}

\begin{figure}[hbt]
	\centering
	\includesvg[width=\textwidth,pretex=\relscale{0.8}]{pics/svg/uaf_architecture}
	\caption[\gls{uaf} architecture overview]{\gls{uaf} architecture overview\footnotemark}
	\label{fig:uaf_architecture}
\end{figure}
\footcitetext[Source: diagram by author, based on][4]{uaf-overview}

\subsubsection{Registration}

The registration process contains different steps. A \gls{fido} server generates a policy object which contains allowed and disallowed authenticators. This data is sent together with the \textit{server challenge}, \textit{username}, \textit{AppID}, and \textit{FacetID} to the client. An AppID describes the \gls{rp} origin, for example, \frqq https://auth.timbrust.de\flqq. Since the created credentials are subject to the same-origin policy, other (sub-)domains are not allowed to access the credentials. With the FacetIDs, a relying party can specific further subdomains that are allowed to access the credential. An example of a valid FacetID is \frqq https://admin.timbrust.de\flqq, where \frqq https://auth.wings.de\flqq{} is an invalid FacetID because the origin is different.\footcites[See][131--132]{10.1007/978-3-319-67639-5_11}[See][17--19]{uaf-protocol}[See][3--4]{uaf-appid-facets}

The client checks that the given AppID matches the requested server and processes the registration. In the first place, the \textit{\gls{fcp}} is generated by hashing the server challenge, AppID, FacetID, and \gls{tls} data. Subsequently, the \gls{asm} computes the \textit{KHAccessToken}, an access control mechanism to prevent unauthorized access to the authenticator. It comprises the AppID, \textit{ASMToken} (a randomly generated and maintained secret by the \gls{asm}), \textit{PersonalID} (a unique ID for each \gls{os} user account), and the \textit{CallerID} (the assigned ID of the \gls{os} for the \gls{fido} client).\footcites[See][131--132]{10.1007/978-3-319-67639-5_11}[See][17--19]{uaf-protocol}

Once the \gls{fcp} and KHAccessToken are generated, the client sends the hashed \gls{fcp}, KHAccessToken, and username to the authenticator. After receiving the data, the authenticator presents the data to the user (e.g., the AppID in a display) and performs user verification. When the user has been verified, and they approved the request, the authenticator generates a new key-pair and stores the data as the \textit{key handle} in its secure storage. The key handle consists of the \textit{public key}, KHAccessToken hash, and username. Also, it can be wrapped, i.e., encrypted in a way that only the client, \gls{asm}, and authenticator can decrypt it again. It has to be noted though, that the exact generation of the key handle is explicitly not specified, i.e., it varies among the vendors of \gls{uaf} authenticators.\footcites[See][9, 16--17]{uaf-asm}

 After that, a \textit{\gls{krd}} object is sent back to the client. It contains the \gls{aaid}, a signature counter, a registration counter, the hashed \gls{fcp}, the public key, the key handle, and the attestation certificate of the authenticator. Further, a signature over the values \gls{aaid}, hashed \gls{fcp}, counters, and the public key is signed by the private attestation key of the authenticator.\footcites[See][12--13]{analysis_fido_master_thesis}[See][22]{uaf-protocol}[See][17]{uaf-auth-commands}

Finally, when the \gls{fido} server receives the registration request (\gls{krd} and signature) from the user agent back, it can cryptographically verify the data by checking the sent signature. Additionally, the \gls{rp} can evaluate the attestation certificate, the \gls{aaid} of the authenticator, and the hash of the \gls{fcp}. Ultimately, the server stores the public key in the database.\footcites[See][192--193]{7897543}[See][23]{uaf-protocol}

\subsubsection{Authentication}

The authentication process is similar to the registration flow. When a user initiates the authentication, the \gls{rp} sends the same payload as in the registration process. The \gls{fido} client again determines the correct authenticator based on the received server policy and the sent AppID. The \gls{fcp} and its hash are generated in the same way as in the registration process. Further, the key handle and KHAccessToken are retrieved from the \gls{rp} database and sent to the authenticator.\footcites[See][132--133]{10.1007/978-3-319-67639-5_11}

When the authenticator receives the key handle, KHAccessToken, and the hash of the \gls{fcp}, this data can be verified by the authenticator. If it matches, the user has been verified, and they approved the authentication request, the corresponding private key is retrieved from the key handle, and the signature counter increased. The authenticator sends the hashed \gls{fcp}, the counter and a \gls{nonce} back to the client. Additionally, a signature signed by the private key consisting of the hashed \gls{fcp}, nonce, and counter is sent back. In return, the client forwards the data to the \gls{rp}. Finally, the \gls{rp} can cryptographically verify the sent data by the signature and proceed with the authentication.\footcites[See][20--21]{uaf-auth-commands}[See][15]{analysis_fido_master_thesis}

\subsubsection{Transaction Confirmation}

Confirming a transaction is a special use case of the authentication process. The only difference between the regular authentication and the transaction confirmation is the additional t\textit{ransaction text} the \gls{fido} server sends to the client. This feature enables the \gls{uaf} protocol to not only authenticate a user but also to let the user confirm certain transactions. A transaction text can be displayed on the authenticator display to show the user details about the transaction. However, the specifications list the authenticator display as optional. In case of the absence of a display, the \gls{asm} can offer the display functions as a software solution.\footcites[See][4]{uaf-overview}[See][251]{Schwartz2018}

\subsubsection{De-registration}

In contrast to the authentication and registration process, the de-registration process of authenticators is done without user verification. The server or client can initiate the process. The necessary information required for the authenticator is the AppID and optionally the specific credential, identified by the KeyID. The \gls{fido} client and \gls{asm} send the required data to the authenticator. To ensure the genuineness of the request, the client checks that the AppID matches the origin of the request.\footcites[See][31]{uaf-protocol}[See][7]{uaf-overview}
