\section{One-time password}

To fully understand how the \gls{otp} works the basics and origins, especially the underlying \gls{mac}, have to be introduced first. In the following subsections are the required algorithms shorty described and in \autoref{subsec:hotp} and \autoref{subsec:totp} the variants of \glspl{otp}, both the \gls{hotp} and the \gls{totp} which are based on \gls{hmac}.

\newpage

\subsection{Message authentication code}

The \gls{mac} is a \textit{code}, i.e., some sort of information to protect and ensure the integrity of a \textit{message}. Integrity, besides confidentially and availably, is one of the key concepts of \gls{it} security. The \gls{mac} is built using two parameters, a secret key that both parties know and the message itself. The algorithm generates a checksum that the sender can send alongside with the message. The recipient calculates the checksum (\gls{mac}) itself from the retrieved message. If it differs then the message has been manipulated or there might have been a faulty transmission. Technically the \gls{mac} can be generated with, e.g., cryptographic-hash functions, such as \gls{hmac}, or using block ciphers such as \gls{cbc-mac}.\footcites[See][565]{320284}[See][163--168]{anderson2008security}[See][391-393]{eckert-it-sec-9}

The \gls{mac} is standardized in different norms from various institutions, for example \gls{nist} \gls{fips} 198-1, the \gls{bsi} technical guideline TR-02102-1 (\frqq Cryptographic Mechanisms: Recommendations and Key Length\flqq{}) or the \gls{iso} norm ISO/IEC 9797-1 and ISO/IEC 9797-2.\footcites[See][]{FIPS198}[See][]{bsi2019recommendations}[See][]{iso9797-1}[See][]{iso9797-2}

\newpage

\begin{figure}[hbt]
	\centering
	\includesvg[width=\textwidth,pretex=\relscale{1}]{pics/svg/mac}
	\caption[Exemplary \gls{mfa} authentication flow]{Exemplary \gls{mfa} authentication flow\footnotemark}
	\label{fig:mac}
\end{figure}
\footnotetext{Source: diagram by author}

\autoref{fig:mac} shows the \gls{mac} in use between Alice and Bob. Both Alice and Bob exchange a secret key only they know via a secure channel. Alice now wants to send a message to Bob. In order to secure the message integrity, she uses an algorithm that takes both message and the secret key as inputs and computes the cryptographic hash of the message, the \gls{mac}. She transmits both the message and the \gls{mac} to Bob. If the message is not confidential, it's also possible to choose an insecure transmission channel. Bob is now able to calculate the \gls{mac} himself by using the same algorithm, key, and the received message from Alice.\\
If his computation of the \gls{mac} matches the one sent by Alice then the integrity and authenticity of the message is present, otherwise the message might have been tampered with.

Mathematically the \gls{mac} is defined as

\begin{equation*}
  	mac = MAC(M, K)
\end{equation*}

Where \textit{M} is the input message, \textit{MAC} the used \gls{mac} function, \textit{K} the shared secret key and \textit{mac} the resulting \glsdesc{mac}.

Sometimes the \gls{mac} is also called \gls{mic} in order to avoid confusion with the \gls{macaddress} address used in network protocols. Further, the \gls{mic} would not prove authenticity since an attacker can just modify the message and re-generate the \gls{mic} of the modified message.\footcites[See][60-62]{265831}

Further, while the \gls{mac} provides authenticity regarding the origin of the data and the data integrity, it does not provide any authenticity regarding the content of the data. For example, mobile code would not be detected by the \gls{mac}, as long as the \gls{mac} belongs to the sent message. This implication has to be taken into account when using the \gls{mac} to authenticate received messages.

\subsection{HMAC}

\gls{hmac} Code is an extension of a \gls{mac} and standardized in \gls{rfc} and \gls{nist} abc.
\cite{krawczyk1997rfc}

\subsection{Counter-based}
\label{subsec:hotp}

HMAC-based One-time Password algorithm, counter based. \gls{rfc} 899. Configurable length (6-10). Default SHA1. Truncation of HMAC
\cite{m2005rfc}

\subsection{Time-based}
\label{subsec:totp}

Time based instead of counter based. \gls{rfc} 123 and \gls{oath}.
\cite{m2011rfc}

\begin{figure}[hbt]
	\centering
	\includesvg[width=\textwidth,pretex=\relscale{1}]{pics/svg/2fa_flow}
	\caption[Exemplary \gls{mfa} authentication flow]{Exemplary \gls{mfa} authentication flow\footnotemark}
	\label{fig:2fa_flow}
\end{figure}
\footnotetext{Source: diagram by author}

\autoref{fig:2fa_flow} shows an example authentication flow using \glspl{totp}. In this scenario the user tries to login to a service that uses \gls{2fa}. After entering their password (knowledge; first factor), they either

\begin{enumerate}[label=(\alph*)]
	\item use, e.g., a smartphone app, or hardware token to generate the \gls{totp}.
	\item receive the \gls{totp} from the service, e.g., via a text message.
\end{enumerate}

Once the user has the \gls{otp} obtained (possession; second factor), they can enter it at the login screen in order to complete the authentication process.

\subsubsection{pros}

\begin{enumerate}
	\item Collisions in MD5 or SHA1 are no problem, already stated/analyzed in the RFC
\end{enumerate}

\subsubsection{cons}

"Just an algorithm"

\begin{enumerate}
	\item synchronization
	\item invalidation
	\item nobody knows how the algorithm is implemented (RFC = no standard)
	\item Differences (e.g. Steam - only 5 digits, limited Alphabet)
	\item Brute Force if server does not limit
	\item Not phishing resistant
\end{enumerate}